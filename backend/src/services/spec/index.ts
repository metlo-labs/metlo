import { v4 as uuidv4 } from "uuid";
import { Not } from "typeorm";
import { RestMethod, SpecExtension } from "../../enums";
import {
  ApiEndpoint,
  ApiTrace,
  MatchedDataClass,
  OpenApiSpec,
} from "../../models";
import Error400BadRequest from "../../errors/error-400-bad-request";
import { JSONValue } from "../../types";
import { AppDataSource } from "../../data-source";
import { getPathRegex } from "../../utils";
import Error409Conflict from "../../errors/error-409-conflict";

export class SpecService {
  static async getSpec(specName: string): Promise<OpenApiSpec> {
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec);
    const spec = await openApiSpecRepository.findOneBy({ name: specName });
    return spec;
  }

  static async getSpecs(): Promise<OpenApiSpec[]> {
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec);
    const specList = await openApiSpecRepository.find({});
    return specList;
  }

  static async updateSpec(
    specObject: JSONValue,
    fileName: string,
    extension: SpecExtension,
    specString: string
  ) {
    await this.deleteSpec(fileName);
    await this.uploadNewSpec(specObject, fileName, extension, specString);
  }

  static async deleteSpec(fileName: string) {
    const apiEndpointRepository = AppDataSource.getRepository(ApiEndpoint);
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec);

    const specEndpoints = await apiEndpointRepository.findBy({
      openapiSpecName: fileName,
    });
    const openApiSpec = await openApiSpecRepository.findOneBy({
      name: fileName,
    });
    if (!openApiSpec) {
      throw new Error400BadRequest(
        "No spec file with the provided name exists."
      );
    }
    for (let i = 0; i < specEndpoints.length; i++) {
      const endpoint = specEndpoints[i];
      endpoint.openapiSpecName = null;
    }
    await apiEndpointRepository.save(specEndpoints);
    await openApiSpecRepository.remove(openApiSpec);
  }

  static async uploadNewSpec(
    specObject: JSONValue,
    fileName: string,
    extension: SpecExtension,
    specString: string
  ) {
    const servers: any[] = specObject["servers"];
    const paths: JSONValue = specObject["paths"];

    if (!servers || servers?.length === 0) {
      throw new Error400BadRequest("No servers found in spec file.");
    }

    const apiEndpointRepository = AppDataSource.getRepository(ApiEndpoint);
    const openApiSpecRepository = AppDataSource.getRepository(OpenApiSpec);
    const apiTraceRepository = AppDataSource.getRepository(ApiTrace);
    const matchedDataClassRepository =
      AppDataSource.getRepository(MatchedDataClass);
    let existingSpec = await openApiSpecRepository.findOneBy({
      name: fileName,
    });
    if (!existingSpec) {
      existingSpec = new OpenApiSpec();
      existingSpec.name = fileName;
      existingSpec.extension = extension;
    }
    existingSpec.spec = specString;
    const pathKeys = Object.keys(paths);
    const endpoints: {
      similarEndpoints: ApiEndpoint[];
      apiEndpoints: ApiEndpoint[];
      traces: ApiTrace[];
      matchedDataClasses: MatchedDataClass[];
    } = {
      similarEndpoints: [],
      apiEndpoints: [],
      traces: [],
      matchedDataClasses: [],
    };
    for (const path of pathKeys) {
      const pathRegex = getPathRegex(path);
      const methods = Object.keys(paths[path]);
      for (const method of methods) {
        for (const server of servers) {
          const host = server["url"];
          if (host) {
            // For exact endpoint match
            let updated = false;
            const methodEnum = method.toUpperCase() as RestMethod;
            let apiEndpoint = await apiEndpointRepository.findOne({
              where: {
                path,
                method: methodEnum,
                host,
              },
              relations: { openapiSpec: true },
            });
            if (!apiEndpoint) {
              apiEndpoint = new ApiEndpoint();
              apiEndpoint.uuid = uuidv4();
              apiEndpoint.path = path;
              apiEndpoint.pathRegex = pathRegex;
              apiEndpoint.method = methodEnum;
              apiEndpoint.host = host;
              apiEndpoint.totalCalls = 0;
              apiEndpoint.openapiSpec = existingSpec;
              //await apiEndpointRepository.save(apiEndpoint);
              updated = true;
            } else if (
              apiEndpoint &&
              (!apiEndpoint.openapiSpecName ||
                apiEndpoint.openapiSpec?.isAutoGenerated)
            ) {
              apiEndpoint.openapiSpec = existingSpec;
              //await apiEndpointRepository.save(apiEndpoint);
              updated = true;
            } else {
              throw new Error409Conflict(
                `Path ${apiEndpoint.path} defined in the given new spec file is already defined in another user defined spec file: ${apiEndpoint.openapiSpecName}`
              );
            }
            endpoints.apiEndpoints.push(apiEndpoint);
            //TODO: For endpoints where path regex matches, update traces to point to new Spec defined endpoint
            if (updated) {
              const similarEndpoints = await apiEndpointRepository.find({
                where: {
                  path: Not(path),
                  pathRegex,
                  method: methodEnum,
                  host,
                },
                relations: {
                  sensitiveDataClasses: true,
                },
              });
              similarEndpoints.forEach(async (endpoint) => {
                apiEndpoint.totalCalls += endpoint.totalCalls;
                apiEndpoint.riskScore = endpoint.riskScore;
                const traces = await apiTraceRepository.findBy({
                  apiEndpointUuid: endpoint.uuid,
                });
                endpoint.sensitiveDataClasses.forEach((matchedDataClass) => {
                  matchedDataClass.apiEndpoint = apiEndpoint;
                });
                traces.forEach((trace) => {
                  trace.apiEndpointUuid = apiEndpoint.uuid;
                });
                //await apiTraceRepository.save(traces);
                endpoints.traces.push(...traces);
                endpoints.matchedDataClasses.push(
                  ...endpoint.sensitiveDataClasses
                );
              });
              endpoints.similarEndpoints.push(...similarEndpoints);
              //await apiEndpointRepository.remove(similarEndpoints);
              //await openApiSpecRepository.save(existingSpec);
            }
          }
        }
      }
    }
    await openApiSpecRepository.save(existingSpec);
    await apiEndpointRepository.save(endpoints.apiEndpoints);
    await apiTraceRepository.save(endpoints.traces);
    await matchedDataClassRepository.save(endpoints.matchedDataClasses);
    await apiEndpointRepository.remove(endpoints.similarEndpoints);
  }
}
